<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Official Instrumental Generator (No Separation)</title>
    <style>
      :root { color-scheme: light dark; }
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        margin: 0;
        padding: 2rem;
        line-height: 1.5;
        background: #0d0f13;
        color: #e6e9ef;
      }
      .container {
        max-width: 880px;
        margin: 0 auto;
        background: #141820;
        border: 1px solid #222839;
        border-radius: 14px;
        padding: 1.5rem;
        box-shadow: 0 6px 24px rgba(0,0,0,0.35);
      }
      h1 { font-size: 1.6rem; margin: 0 0 0.75rem; }
      p { margin: 0.25rem 0; opacity: 0.9; }
      .row { display: flex; flex-wrap: wrap; gap: 1rem; align-items: center; }
      input[type="file"] {
        padding: 0.5rem;
        border-radius: 8px;
        border: 1px solid #2a3145;
        background: #0f131a;
        color: #e6e9ef;
      }
      button {
        background: #3b82f6;
        color: white;
        border: none;
        padding: 0.6rem 0.9rem;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 600;
      }
      button.secondary { background: #64748b; }
      button:disabled { opacity: 0.6; cursor: not-allowed; }
      .status { margin-top: 1rem; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
      .audio-wrap { margin-top: 1rem; }
      .note { font-size: 0.9rem; opacity: 0.8; }
      .badge { display: inline-block; padding: 0.25rem 0.5rem; border-radius: 6px; background: #1f2937; border: 1px solid #334155; font-size: 0.8rem; }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Official Instrumental Generator</h1>
      <p class="note">No stem separation. Generates a fresh instrumental influenced by your song upload.</p>
      <p class="note">Important: An actual "official" instrumental of a copyrighted song requires rights from the original rights holders. This tool creates a new instrumental from scratch using your file as a creative seed.</p>

      <div class="row" style="margin-top: 1rem;">
        <input type="file" id="songFile" accept="audio/*" />
        <button id="generateBtn" disabled>Generate Instrumental</button>
        <button id="regenBtn" class="secondary" disabled>Regenerate Variation</button>
        <button id="testBtn" class="secondary">Audio Test</button>
        <button id="playBtn" class="secondary" disabled>Play Preview</button>
        <button id="stopBtn" class="secondary" disabled>Stop</button>
        <button id="downloadBtn" class="secondary" disabled>Download WAV</button>
        <span id="paramsBadge" class="badge" title="Generation parameters"></span>
      </div>

      <div id="status" class="status">Upload a song to begin.</div>
      <div class="audio-wrap">
        <audio id="previewAudio" controls style="width:100%; display:none"></audio>
      </div>
    </div>

    <!-- Tone.js -->
    <script src="https://unpkg.com/tone@latest/build/Tone.js"></script>
    <script>
      const fileInput = document.getElementById('songFile');
      const generateBtn = document.getElementById('generateBtn');
      const regenBtn = document.getElementById('regenBtn');
      const testBtn = document.getElementById('testBtn');
      const playBtn = document.getElementById('playBtn');
      const stopBtn = document.getElementById('stopBtn');
      const downloadBtn = document.getElementById('downloadBtn');
      const statusEl = document.getElementById('status');
      const previewAudio = document.getElementById('previewAudio');
      const paramsBadge = document.getElementById('paramsBadge');

      let recorder = null;
      let recordedBlob = null;
      let parts = [];
      let synths = {};
      let compositionLengthSeconds = 8; // shorter render for faster generation
      let variation = 0; // increment to regenerate new variation for the same file

      fileInput.addEventListener('change', () => {
        if (fileInput.files && fileInput.files.length > 0) {
          generateBtn.disabled = false;
          statusEl.textContent = 'Ready. Click Generate Instrumental.';
        } else {
          generateBtn.disabled = true;
          statusEl.textContent = 'Upload a song to begin.';
        }
      });

      function bytesToHex(bytes) {
        return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
      }

      async function hashFile(file) {
        // Speed-up: hash only the first 256KB instead of the whole file
        const CHUNK_SIZE = 256 * 1024;
        const chunk = file.slice(0, CHUNK_SIZE);
        const buf = await chunk.arrayBuffer();
        const digest = await crypto.subtle.digest('SHA-256', buf);
        const bytes = new Uint8Array(digest);
        return bytesToHex(bytes);
      }

      function deriveParamsFromHash(hashHex, salt = 0) {
        // Use slices of the hash to derive deterministic parameters
        const h = hashHex;
        const toInt = (hex) => parseInt(hex, 16);
        const bpm = 88 + ((toInt(h.slice(0, 2)) + salt) % 53); // 88..140
        const isMajor = ((toInt(h.slice(2, 4)) + salt) % 2) === 0;
        const roots = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const root = roots[(toInt(h.slice(4, 6)) + salt) % roots.length];
        const energy = ((toInt(h.slice(6, 8)) + salt) % 100) / 100; // 0..1
        return { bpm, isMajor, root, energy };
      }

      function buildScale(root, isMajor) {
        // Very simple chromatic and major/minor mapping
        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const majorSteps = [0, 2, 4, 5, 7, 9, 11];
        const minorSteps = [0, 2, 3, 5, 7, 8, 10];
        const rootIndex = notes.indexOf(root);
        const steps = isMajor ? majorSteps : minorSteps;
        const scale = steps.map(s => notes[(rootIndex + s) % 12]);
        return scale;
      }

      function chordFromScale(scale, degree, octave = 4) {
        // Triads: degree, degree+2, degree+4
        const i = degree % scale.length;
        const third = (i + 2) % scale.length;
        const fifth = (i + 4) % scale.length;
        return [
          `${scale[i]}${octave}`,
          `${scale[third]}${octave + (third < i ? 1 : 0)}`,
          `${scale[fifth]}${octave + (fifth < i ? 1 : 0)}`
        ];
      }

      function clearParts() {
        parts.forEach(p => p.dispose());
        parts = [];
        Object.values(synths).forEach(s => s.dispose());
        synths = {};
      }

      function scheduleComposition(params, scale) {
        const { bpm, energy, bars } = params;
        Tone.Transport.cancel();
        Tone.Transport.bpm.value = bpm;
        Tone.Transport.timeSignature = 4;

        // Instruments
        const master = new Tone.Gain(0.95);
        const comp = new Tone.Compressor(-12, 3);
        const limiter = new Tone.Limiter(-1);
        master.chain(comp, limiter, Tone.getDestination());

        const kick = new Tone.MembraneSynth({ pitchDecay: 0.02, octaves: 8, envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.8 } });
        const snare = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.2, sustain: 0 }, filterEnvelope: { attack: 0.001, decay: 0.1, sustain: 0 }, volume: -6 });
        const hat = new Tone.MetalSynth({ frequency: 250, envelope: { attack: 0.001, decay: 0.12, release: 0.1 }, volume: -10 });
        const bass = new Tone.MonoSynth({ oscillator: { type: 'square' }, filter: { Q: 2, type: 'lowpass', rolloff: -24 }, envelope: { attack: 0.02, decay: 0.2, sustain: 0.6, release: 0.4 }, volume: -4 });
        const poly = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'triangle' }, envelope: { attack: 0.02, decay: 0.2, sustain: 0.6, release: 0.8 } });
        const lead = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.5, release: 0.6 }, volume: -8 });

        kick.connect(master);
        snare.connect(master);
        hat.connect(master);
        bass.connect(master);
        poly.connect(master);
        lead.connect(master);
        synths = { kick, snare, hat, bass, poly, lead };

        // Precompute durations in seconds based on current bpm
        const barSeconds = Tone.Time('1m').toSeconds();
        const halfNoteSeconds = Tone.Time('2n').toSeconds();
        const quarterNoteSeconds = Tone.Time('4n').toSeconds();
        const eighthSeconds = Tone.Time('8n').toSeconds();

        // Rhythm patterns
        const kickPart = new Tone.Part((time, note) => { kick.triggerAttackRelease(note, '8n', time); }, []);
        const snarePart = new Tone.Part((time) => { snare.triggerAttackRelease('16n', time); }, []);
        const hatPart = new Tone.Part((time) => { hat.triggerAttackRelease('32n', time); }, []);

        for (let b = 0; b < bars; b++) {
          const barStart = b * barSeconds;
          // Kick on beats 1 and 3
          kickPart.add({ time: barStart, note: 'C1' });
          kickPart.add({ time: barStart + halfNoteSeconds, note: 'C1' });
          if (energy > 0.5) {
            // Extra syncopation slightly before beat 3
            kickPart.add({ time: barStart + quarterNoteSeconds * 3, note: 'C1' });
          }

          // Snare on beats 2 and 4
          snarePart.add(barStart + quarterNoteSeconds);
          snarePart.add(barStart + quarterNoteSeconds * 3);

          // Hats every 8th across the bar
          for (let s = 0; s < 8; s++) {
            hatPart.add(barStart + s * eighthSeconds);
          }
        }

        kickPart.start(0);
        snarePart.start(0);
        hatPart.start(0);
        parts.push(kickPart, snarePart, hatPart);

        // Harmonic progression: I–V–vi–IV repeated
        const degrees = [0, 4, 5, 3];
        const progPart = new Tone.Part((time, chord) => { poly.triggerAttackRelease(chord, '2n', time); }, []);
        const bassPart = new Tone.Part((time, note) => { bass.triggerAttackRelease(note, '4n', time); }, []);
        for (let b = 0; b < bars; b++) {
          const barStart = b * barSeconds;
          const deg = degrees[b % degrees.length];
          const chord = chordFromScale(scale, deg, 4);
          const bassNote = `${scale[deg]}2`;
          progPart.add({ time: barStart, chord });
          bassPart.add({ time: barStart, note: bassNote });
          bassPart.add({ time: barStart + halfNoteSeconds, note: bassNote });
        }
        progPart.start(0);
        bassPart.start(0);
        parts.push(progPart, bassPart);

        // Simple lead motif derived from energy
        const leadPart = new Tone.Part((time, note) => { lead.triggerAttackRelease(note, '8n', time); }, []);
        const motifDegrees = energy > 0.6 ? [0, 2, 4, 2, 5, 4, 2, 0] : [0, 1, 3, 1, 4, 3, 1, 0];
        for (let b = 0; b < bars; b++) {
          const barStart = b * barSeconds;
          for (let i = 0; i < motifDegrees.length; i++) {
            const note = `${scale[motifDegrees[i] % scale.length]}5`;
            leadPart.add({ time: barStart + i * eighthSeconds, note });
          }
        }
        leadPart.start(0);
        parts.push(leadPart);
      }

      async function getAudioDuration(file) {
        const arrayBuffer = await file.arrayBuffer();
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
        audioCtx.close();
        return audioBuffer.duration;
      }

      function audioBufferToWav(audioBuffer) {
        const numChannels = audioBuffer.numberOfChannels;
        const sampleRate = audioBuffer.sampleRate;
        const format = 1; // PCM
        const bitDepth = 16;

        const channelData = [];
        for (let i = 0; i < numChannels; i++) {
          channelData.push(audioBuffer.getChannelData(i));
        }

        const length = audioBuffer.length * numChannels * (bitDepth / 8);
        const buffer = new ArrayBuffer(44 + length);
        const view = new DataView(buffer);

        function writeString(view, offset, string) {
          for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
          }
        }

        let offset = 0;
        writeString(view, offset, 'RIFF'); offset += 4;
        view.setUint32(offset, 36 + length, true); offset += 4;
        writeString(view, offset, 'WAVE'); offset += 4;
        writeString(view, offset, 'fmt '); offset += 4;
        view.setUint32(offset, 16, true); offset += 4; // Subchunk1Size
        view.setUint16(offset, format, true); offset += 2; // AudioFormat
        view.setUint16(offset, numChannels, true); offset += 2; // NumChannels
        view.setUint32(offset, sampleRate, true); offset += 4; // SampleRate
        view.setUint32(offset, sampleRate * numChannels * (bitDepth / 8), true); offset += 4; // ByteRate
        view.setUint16(offset, numChannels * (bitDepth / 8), true); offset += 2; // BlockAlign
        view.setUint16(offset, bitDepth, true); offset += 2; // BitsPerSample
        writeString(view, offset, 'data'); offset += 4;
        view.setUint32(offset, length, true); offset += 4;

        // Write interleaved PCM
        const volume = 1;
        for (let i = 0; i < audioBuffer.length; i++) {
          for (let ch = 0; ch < numChannels; ch++) {
            const sample = Math.max(-1, Math.min(1, channelData[ch][i] * volume));
            view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
            offset += 2;
          }
        }
        return new Blob([view], { type: 'audio/wav' });
      }

      async function generateInstrumental() {
        if (!fileInput.files || fileInput.files.length === 0) return;
        const file = fileInput.files[0];
        statusEl.textContent = 'Analyzing file and preparing generation...';
        await Tone.start();

        const durationSec = await getAudioDuration(file);
        const hashHex = await hashFile(file);
        const baseParams = deriveParamsFromHash(hashHex, variation);
        const scale = buildScale(baseParams.root, baseParams.isMajor);

        // Compute bar count to roughly match the song length
        const beatsPerBar = 4;
        const secondsPerBar = beatsPerBar * 60 / baseParams.bpm;
        const bars = Math.max(4, Math.round(durationSec / secondsPerBar));
        const totalDuration = bars * secondsPerBar;

        paramsBadge.textContent = `${baseParams.root} ${baseParams.isMajor ? 'Major' : 'Minor'} • ${baseParams.bpm} BPM • ~${Math.round(totalDuration)}s • Var ${variation}`;

        clearParts();

        statusEl.textContent = 'Generating instrumental (offline render)...';
        const toneBuffer = await Tone.Offline(() => {
          // Schedule inside offline context
          scheduleComposition({ ...baseParams, bars }, scale);
        }, totalDuration);

        const audioBuffer = toneBuffer.get();
        recordedBlob = audioBufferToWav(audioBuffer);

        const url = URL.createObjectURL(recordedBlob);
        previewAudio.src = url;
        previewAudio.style.display = 'block';
        playBtn.disabled = false;
        stopBtn.disabled = false;
        downloadBtn.disabled = false;
        statusEl.textContent = 'Instrumental ready. You can preview or download.';
      }

      generateBtn.addEventListener('click', async () => {
        generateBtn.disabled = true;
        regenBtn.disabled = true;
        playBtn.disabled = true;
        stopBtn.disabled = true;
        downloadBtn.disabled = true;
        previewAudio.pause();
        await generateInstrumental();
        generateBtn.disabled = false;
        regenBtn.disabled = false;
      });

      regenBtn.addEventListener('click', async () => {
        if (!fileInput.files || fileInput.files.length === 0) return;
        variation++;
        generateBtn.click();
      });

      playBtn.addEventListener('click', () => {
        if (previewAudio.src) {
          previewAudio.play();
        }
      });

      stopBtn.addEventListener('click', () => {
        previewAudio.pause();
        previewAudio.currentTime = 0;
      });

      downloadBtn.addEventListener('click', () => {
        if (!recordedBlob) return;
        const a = document.createElement('a');
        a.href = URL.createObjectURL(recordedBlob);
        a.download = 'instrumental.wav';
        a.click();
      });

      // Quick offline audio test to confirm sound works
      testBtn.addEventListener('click', async () => {
        statusEl.textContent = 'Running audio test...';
        await Tone.start();
        const toneBuffer = await Tone.Offline(() => {
          const master = new Tone.Gain(0.95).toDestination();
          const testSynth = new Tone.Synth({ oscillator: { type: 'sine' } });
          testSynth.connect(master);
          const testPart = new Tone.Part((time) => {
            testSynth.triggerAttackRelease('A4', '8n', time);
          }, [{ time: 0 }, { time: 0.5 }]);
          testPart.start(0);
        }, 1.0);
        recordedBlob = audioBufferToWav(toneBuffer.get());
        const url = URL.createObjectURL(recordedBlob);
        previewAudio.src = url;
        previewAudio.style.display = 'block';
        playBtn.disabled = false;
        stopBtn.disabled = false;
        downloadBtn.disabled = false;
        statusEl.textContent = 'Audio test ready. Press Play.';
      });
    </script>
  </body>
  </html>